## 연관관계 매핑 기초
### 객체지향스럽지 않게 모델링
- 시나리오 예시) Member : Team = N : 1
- 객체를 테이블에 맞추어 데이터 중심으로 모델링하면, 협력 관계를 만들 수 없다.
  - 테이블은 외래키로 조인을 사용해서 연관된 테이블을 찾는다.
  - 객체는 참조를 사용해서 연관된 객체를 찾는다.
  - 테이블과 객체 사이에는 이런 큰 간격이 있다.

### 양방향 연관관계와 연관관계의 주인
- 테이블의 연관관계
  - 테이블은 fk 로 연결되는 점에서는 단방향 연관관계와 차이가 없다.

- 객체의 연관관계
  - Member 객체에는 아래와 같이 연결되고,
  ```markdown
  @ManyToOne
  @JoinColumn(name = "TEAM_ID")
  private Team team;
  ```
  - Team 객체에는 아래와 같이 연결된다.
  ```markdown
  @OneToMany(mappedBy = "team")
  private List<Member> members = new ArrayList<>();
  ```

- 연관관계의 주인과 mappedBy(***)
  - 객체와 테이블이 관계를 맺는 차이
    - 객체 연관관계 => 2개
      - 회원 -> 팀 연관관계 1개(단방향)
      - 팀 -> 회원 연관관계 1개(단방향)
    - 테이블 연관관계
      - fk 하나로 연관관계가 끝난다.
      - 회원 <-> 팀의 연관관계 1개(양방향)
  
  - 객체의 양방향 관계는 사실 양방향 관계가 아니라 서로 다른 단방향 관계 2개다.
  - 객체를 양방향으로 참조하려면 단방향 연관관계를 2개를 만들어야 한다.
  - 테이블의 양방향 관계는 외래키 하나로 두 테이블의 연관관계를 관리한다.
  - Member.TEAM_ID 외래키 하나로 양방향 연관관계 가진다.

- 만약, member, team 값 바꿀 때 무얼 바꿔야 하는가?
- 연관관계의 주인
  - 연관관계의 주인만이 외래키를 관리(등록, 수정)
  - 주인이 아닌쪽은 읽기만 가능(***)
  - 주인은 mappedBy 속성 사용 X
  - 주인이 아니면 mappedBy 속성으로 주인 지정
  - 즉, Member.team 이 연관계의 주인!!!
  - Team.members 는 가짜 매핑, 주인의 반대편
  - 외래키가 있는 곳이 주인, ManyToOne 즉 '다' 쪽이 연관관계의 주인
  - 연관관계의 주인은 비즈니스적으로 중요한 게 아니다.