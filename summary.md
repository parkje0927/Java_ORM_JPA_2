## 연관관계 매핑 기초
### 객체지향스럽지 않게 모델링
- 시나리오 예시) Member : Team = N : 1
- 객체를 테이블에 맞추어 데이터 중심으로 모델링하면, 협력 관계를 만들 수 없다.
  - 테이블은 외래키로 조인을 사용해서 연관된 테이블을 찾는다.
  - 객체는 참조를 사용해서 연관된 객체를 찾는다.
  - 테이블과 객체 사이에는 이런 큰 간격이 있다.

### 양방향 연관관계와 연관관계의 주인
- 테이블의 연관관계
  - 테이블은 fk 로 연결되는 점에서는 단방향 연관관계와 차이가 없다.

- 객체의 연관관계
  - Member 객체에는 아래와 같이 연결되고,
  ```markdown
  @ManyToOne
  @JoinColumn(name = "TEAM_ID")
  private Team team;
  ```
  - Team 객체에는 아래와 같이 연결된다.
  ```markdown
  @OneToMany(mappedBy = "team")
  private List<Member> members = new ArrayList<>();
  ```

- 연관관계의 주인과 mappedBy(***)
  - 객체와 테이블이 관계를 맺는 차이
    - 객체 연관관계 => 2개
      - 회원 -> 팀 연관관계 1개(단방향)
      - 팀 -> 회원 연관관계 1개(단방향)
    - 테이블 연관관계
      - fk 하나로 연관관계가 끝난다.
      - 회원 <-> 팀의 연관관계 1개(양방향)
  
  - 객체의 양방향 관계는 사실 양방향 관계가 아니라 서로 다른 단방향 관계 2개다.
  - 객체를 양방향으로 참조하려면 단방향 연관관계를 2개를 만들어야 한다.
  - 테이블의 양방향 관계는 외래키 하나로 두 테이블의 연관관계를 관리한다.
  - Member.TEAM_ID 외래키 하나로 양방향 연관관계 가진다.

- 만약, member, team 값 바꿀 때 무얼 바꿔야 하는가?
- 연관관계의 주인
  - 연관관계의 주인만이 외래키를 관리(등록, 수정)
  - 주인이 아닌쪽은 읽기만 가능(***)
  - 주인은 mappedBy 속성 사용 X
  - 주인이 아니면 mappedBy 속성으로 주인 지정
  - 즉, Member.team 이 연관계의 주인!!!
  - Team.members 는 가짜 매핑, 주인의 반대편
  - 외래키가 있는 곳이 주인, ManyToOne 즉 '다' 쪽이 연관관계의 주인
  - 연관관계의 주인은 비즈니스적으로 중요한 게 아니다.
  
### 양방향 매핑시 가장 많이 하는 실수
- 연관관계의 주인에 값을 입력하지 않음.
```markdown
Member 에 있는 team 이 연관관계의 주인이다.
만약 Member.setTeam 안 하면 값이 외래키 값이 Null 이다.
```

- 순수한 객체 관계를 고려하면 항상 양쪽 다 값을 입력해야 한다.
- 연관관계 편의 메소드를 생성하자
  - 예를 들어, member.setTeam() 할 때, 그 메소드 안에 team.getMembers().add(this); 로 수행해주자
- 양방향 매핑 시에 무한 루프를 조심하자
  - 예를 들어, toString(), lombok, JSON 생성 라이브러리
  - 양쪽 클래스에 toString() 메소드를 다 생성해서 호출하면 무한 루프에 빠진다.
  - 롬복에서 ToString 은 빼고 쓰자!!!
  - Controller 에서 엔티티를 JSON 으로 반환하지 말자!!!(***)
  - 엔티티는 DTO 로 변경해서 반환하자!!!

### 양방향 매핑 정리
- 단방향 매핑만으로도 이미 연관관계 매핑은 완료
- 웬만하면 단방향으로 끝내야 한다.
- 양방향 매핑은 반대 방향으로 조회(객체 그래프 탐색) 기능이 추가된 것 뿐
- JPQL 에서 역방향으로 탐색할 일이 많음.
- 단방향 매핑을 잘 하고 양방향은 필요할 때 추가해도 됨(테이블에 영향을 주지 않음.)

### 연관관계 매핑시 고려사항 3가지
1) 다중성
- 다대일 ManyToOne
- 일대다 OneToMany
- 일대일 OneToOne
- 다대다 ManyToMany -> 실무에서 쓰면 안된다.

2) 단방향, 양방향
- 테이블
  - 외래키 하나로 양쪽 조인 가능
  - 사실 방향이라는 개념이 없음
- 객체
  - 참조용 필드가 있는 쪽으로만 참조 가능
  - 한쪽만 참조하면 단방향
  - 양쪽이 서로 참조하면 양방향

3) 연관관계의 주인
- 테이블은 외래키 하나로 두 테이블이 연관관계를 맺음.
- 객체 양방향 관계는 A -> B, B -> A 처럼 참조가 2군데
- 객체 양항향 관계는 참조가 2군데 있음. 둘 중 테이블의 외래키를 관리할 곳을 지정해야 함.
- 연관관계의 주인 : 외래키를 관리하는 참조
- 주인의 반대편 : 외래키에 영향을 주지 않음, 단순 조회만 가능

### 다대일 [N:1]
- 다N 쪽에 외래키가 있다.
- 가장 많이 사용한다.

- 단방향
```java
public class Member {

  //...
  
  @ManyToOne
  @JoinColumn(name = "TEAM_ID")
  private Team team;
}

public class Team {
  //Team 은 그냥 두면 된다.
}
```

- 양방향
  - 외래키가 있는 쪽이 연관관계의 주인
  - 양쪽이 서로 참조할 때
```java
public class Member {

  //...

  @ManyToOne
  @JoinColumn(name = "TEAM_ID")
  private Team team;
}

public class Team {

  //...

  @OneToMany(mappedBy = team)
  private List<Member> members = new ArrayList<>();
}
```

### 일대다 1:N
- 이 모델은 권장하진 않는다. 실무에서 거의 안 쓴다.
- 왜냐면 insert 후 다시 update 쿼리가 일어나게 되므로 실무에서 쓰기에는 위험하다.

- 단방향
  - Team 에 있는 members 가 연관관계의 주인이 된다.
  - 1이 연관관계의 주인
  - 테이블은 다쪽에 외래키가 있다.
  - 객체와 테이블의 차이 때문에 반대편 테이블의 외래키를 관리하는 특이한 구조
  - @JoinColumn 을 꼭 사용해야 한다. 그렇지 않으면 조인 테이블 방식을 사용함(중간에 테이블을 하나 추가함)

  - 엔티티가 관리하는 외래키가 다른 테이블에 있음.
  - 연관관계 관리를 위해 추가로 UPDATE SQL 실행
  - 일대다 단방향 매핑보다는 **다대일 양방향 매핑**을 사용하자

```java
public class Member {

  //...
  
}

public class Team {

  //...

  @OneToMany
  @JoinColumn(name = "TEAM_ID")
  private List<Member> members = new ArrayList<>();
}
```

- 양방향
  - 이런 매핑은 공식적으로 존재 X
  - 읽기 전용 필드를 사용해서 양방향처럼 사용하는 방법
  - 다대일 양방향을 사용하자!!!!

```java
public class Member {

  //...
  //연관관계 주인은 Team 의 members 이기 때문에(일대다니까) -> insertable, updatable false 를 해서 읽기 전용으로 만들어버린다.
  @ManyToOne
  @JoinColumn(insertable = false, updatable = false)
  private Team team;
}

public class Team {

  //...

  @OneToMany
  @JoinColumn(name = "TEAM_ID")
  private List<Member> members = new ArrayList<>();
}
<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> 79292bf ([UPDATE] 일대일 1:1)
```

### 일대일
- 그 반대도 일대일
- 주 테이블이나 대상 테이블 중에 외래키 선택 가능
  - 주 테이블에 외래키
  - 대상 테이블에 외래키
- 외래키에 데이터베이스 유니크 제약 조건 추가
- 다대일 양방향 매핑처럼 외래키가 있는 곳이 연관관계의 주인
- 반대편은 mappedBy 적용

<br>

- 단방향 관계는 JPA 지원 X
- 양방향 관계는 지원

<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> cc81644 ([UPDATE] 정리 내용 수정)
### 정리
- 주 테이블에 외래키
  - 주 객체가 대상 객체의 참조를 가지는 것처럼 주 테이블에 외래키를 두고 대상 테이블을 찾음.
  - 객체지향 개발자 선호
  - JPA 매핑 관리
  - 장점 : 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능
  - 단점 : 값이 없으면 외래키에 null 허용
- 대상 테이블에 외래키
  - 대상 테이블에 외래키가 존재
  - 전통적인 데이터베이스 개발자 선호
  - 장점 : 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조 유지
<<<<<<< HEAD
  - 단점 : 프록시 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩됨.

### 다대다
- 다대다는 실무에서 사용 X
=======
```
>>>>>>> 28c4f06 ([UPDATE] 다대일, 일대다 연관관계)
=======
- 정리
  - 주 테이블에 외래키
    - 주 객체가 대상 객체의 참조를 가지는 것처럼 주 테이블에 외래키를 두고 대상 테이블을 찾음.
    - 객체지향 개발자 선호
    - JPA 매핑 관리
    - 장점 : 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능
    - 단점 : 값이 없으면 외래키에 null 허용
  - 대상 테이블에 외래키
    - 대상 테이블에 외래키가 존재
    - 전통적인 데이터베이스 개발자 선호
    - 장점 : 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조 유지
    - 단점 : 프록시 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩됨.
>>>>>>> 79292bf ([UPDATE] 일대일 1:1)
=======
  - 단점 : 프록시 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩됨.
>>>>>>> cc81644 ([UPDATE] 정리 내용 수정)
